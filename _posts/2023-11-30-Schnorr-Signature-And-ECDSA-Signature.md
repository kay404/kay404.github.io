# Schnorr 签名算法 和 ECDSA 签名算法

已知椭圆曲线基点 `G`, 和签名消息 `m`，对于签名者，签名的私钥 `x`，公钥 `X = x * G`。

## Schnorr 签名算法

签名过程如下：

1. 生成随机数 `k`, `R = k * G`。
2. 将 `R` 和 `m` 拼接后计算哈希 `H(R, m)`。
3. 计算 `s = k + H(R, m) * x`。
4. (R, s) 即为签名。

对于验签者拿到签名 `(R, s)`，在已知 `m`、`G`、`X`  的情况下，签名的验证就是检查下面的等式是否成立:

<center>s * G == R + H(R, m) * X</center>

Schnorr 签名是线性，这在签名的聚合或者多重签名上具有天然优势。对于两个人同时签名同一个消息，生成消息哈希使用 `R = R1 + R2`，那么：

```text
  Sig_1(m, k1, s1) + Sig_2(m, k2, s2)
= (R1, k1 + H(R, m) * s1) + (R2, k2 + H(R, m) * s2)
= (R1 + R2, (k1 + k2) + H(R, m) * (s1 + s2))
= (R, (k1 + k2) + H(R, m) * (s1 + s2))
= Sig(m, k1 + k2, s1 + s2)
```

在多重签名下生成的签名数据和单个签名数据大小是一样的。

## ECDSA 签名算法

签名过程如下：

1. 生成随机数 `k`，`P = k * G`，取 `P` 的 x 坐标为 `r`。
2. 计算消息的哈希 `H(m)`。
3. 计算 `s = k^-1 * (H(m) + x * r)`。(`k^-1` 是 `k`的[模的乘法逆元](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0))
4. (r, s) 即为签名。

对于验签者拿到签名 `(r, s)`，同样在已知 `m`、`G`、`X`  的情况下，验签过程如下：

1. 计算 `P = s^-1 * H(m) * G + r * X`。
2. 验证 `P` 的 x 坐标值 `Px` 是否等于 `r`，相等则验签通过，否则失败。

对于 ECDSA 签名并不支持线性。在多重签名下需要存储多个签名数据。

## 总结

Schnorr 相对 ECDSA 来说签名和验证速度更快，签名的聚合以及多重签名更加高效。
